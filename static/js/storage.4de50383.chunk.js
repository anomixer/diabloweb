(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{5:function(e,o,t){"use strict";t.d(o,"a",function(){return i});var r=t(9),n=t.n(r);async function s(e,o){const t=await e.get(o.toLowerCase());if(t){const e=new Blob([t],{type:"binary/octet-stream"}),r=URL.createObjectURL(e),n=document.createElement("a");n.setAttribute("href",r),n.setAttribute("download",o),document.body.appendChild(n),n.click(),document.body.removeChild(n),URL.revokeObjectURL(r)}else console.error("File ".concat(o," does not exist"))}const a=e=>new Promise((o,t)=>{const r=new FileReader;r.onload=(()=>o(r.result)),r.onerror=(()=>t(r.error)),r.onabort=(()=>t()),r.readAsArrayBuffer(e)});async function i(e){try{const e=new n.a("diablo_fs"),t=new Map;for(let[o,r]of Object.entries(await e.json()))t.set(o,r);return window.DownloadFile=(o=>s(e,o)),window.DownloadSaves=(()=>(async function(e){for(let o of await e.keys())o.match(/\.sv$/i)&&s(e,o)})(e)),{files:t,update:(o,t)=>e.set(o,t),delete:o=>e.remove(o),clear:()=>e.clear(),download:o=>s(e,o),upload:o=>(async function(e,o,t){const r=new Uint8Array(await a(t));return o.set(t.name.toLowerCase(),r),e.set(t.name.toLowerCase(),r)})(e,t,o),fileUrl:async o=>{const t=await e.get(o.toLowerCase());if(t){const e=new Blob([t],{type:"binary/octet-stream"});return URL.createObjectURL(e)}}}}catch(o){return window.DownloadFile=(()=>console.error("IndexedDB is not supported")),window.DownloadSaves=(()=>console.error("IndexedDB is not supported")),{files:new Map,update:()=>Promise.resolve(),delete:()=>Promise.resolve(),clear:()=>Promise.resolve(),download:()=>Promise.resolve(),upload:()=>Promise.resolve(),fileUrl:()=>Promise.resolve()}}}},80:function(e,o,t){"use strict";t.r(o);var r=t(5);const n=Object(r.a)();window.addEventListener("message",e=>{let{data:o,source:t}=e;"transfer"===o.method?n.then(e=>{let{files:o}=e;t.postMessage({method:"storage",files:o},"*")}):"clear"===o.method&&n.then(e=>{let{clear:o}=e;return o()})})}},[[80,3,0]]]);
//# sourceMappingURL=storage.4de50383.chunk.js.map