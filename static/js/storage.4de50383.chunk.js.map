{"version":3,"sources":["fs.js","storage.js"],"names":["__webpack_require__","d","__webpack_exports__","create_fs","idb_kv_store__WEBPACK_IMPORTED_MODULE_0__","idb_kv_store__WEBPACK_IMPORTED_MODULE_0___default","n","async","downloadFile","store","name","file","get","toLowerCase","blob","Blob","type","url","URL","createObjectURL","lnk","document","createElement","setAttribute","body","appendChild","click","removeChild","revokeObjectURL","console","error","concat","readFile","Promise","resolve","reject","reader","FileReader","onload","result","onerror","onabort","readAsArrayBuffer","load","IdbKvStore","files","Map","data","Object","entries","json","set","window","DownloadFile","DownloadSaves","keys","match","downloadSaves","update","delete","remove","clear","download","upload","Uint8Array","uploadFile","fileUrl","e","r","_fs__WEBPACK_IMPORTED_MODULE_0__","fs","addEventListener","_ref","source","method","then","_ref2","postMessage","_ref3"],"mappings":"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","file":"static/js/storage.4de50383.chunk.js","sourcesContent":["import IdbKvStore from  'idb-kv-store';\r\n\r\n/*const importStorage = () => new Promise((resolve, reject) => {\r\n  let done = false;\r\n  const frame = document.createElement('iframe');\r\n  window.addEventListener('message', ({data}) => {\r\n    if (data.method === 'storage' && !done) {\r\n      done = true;\r\n      resolve(data.files);\r\n      frame.contentWindow.postMessage({method: 'clear'}, '*');\r\n    }\r\n  });\r\n  frame.addEventListener('load', () => {\r\n    frame.contentWindow.postMessage({method: 'transfer'}, '*');\r\n  });\r\n  frame.addEventListener('error', () => {\r\n    if (!done) {\r\n      done = true;\r\n      resolve(null);\r\n    }\r\n  });\r\n  frame.src = \"https://diablo.rivsoft.net/storage.html\";\r\n  frame.style.display = \"none\";\r\n  document.body.appendChild(frame);\r\n  setTimeout(() => {\r\n    if (!done) {\r\n      done = true;\r\n      resolve(null);\r\n    }\r\n  }, 10000);\r\n});*/\r\n\r\nasync function downloadFile(store, name) {\r\n  const file = await store.get(name.toLowerCase());\r\n  if (file) {\r\n    const blob = new Blob([file], {type: 'binary/octet-stream'});\r\n    const url = URL.createObjectURL(blob);\r\n    const lnk = document.createElement('a');\r\n    lnk.setAttribute('href', url);\r\n    lnk.setAttribute('download', name);\r\n    document.body.appendChild(lnk);\r\n    lnk.click();\r\n    document.body.removeChild(lnk);\r\n    URL.revokeObjectURL(url);\r\n  } else {\r\n    console.error(`File ${name} does not exist`);\r\n  }\r\n}\r\n\r\nasync function downloadSaves(store) {\r\n  for (let name of await store.keys()) {\r\n    if (name.match(/\\.sv$/i)) {\r\n      downloadFile(store, name);\r\n    }\r\n  }\r\n}\r\n\r\nconst readFile = file => new Promise((resolve, reject) => {\r\n  const reader = new FileReader();\r\n  reader.onload = () => resolve(reader.result);\r\n  reader.onerror = () => reject(reader.error);\r\n  reader.onabort = () => reject();\r\n  reader.readAsArrayBuffer(file);\r\n});\r\nasync function uploadFile(store, files, file) {\r\n  const data = new Uint8Array(await readFile(file));\r\n  files.set(file.name.toLowerCase(), data);\r\n  return store.set(file.name.toLowerCase(), data);\r\n}\r\n\r\nexport default async function create_fs(load) {\r\n  try {\r\n    const store = new IdbKvStore('diablo_fs');\r\n    const files = new Map();\r\n    for (let [name, data] of Object.entries(await store.json())) {\r\n      files.set(name, data);\r\n    }\r\n    /*if (load) {\r\n      const files = await importStorage();\r\n      if (files) {\r\n        for (let [name, data] of files) {\r\n          files.set(name, data);\r\n          store.set(name, data);\r\n        }\r\n      }\r\n    }*/\r\n    window.DownloadFile = name => downloadFile(store, name);\r\n    window.DownloadSaves = () => downloadSaves(store);\r\n    return {\r\n      files,\r\n      update: (name, data) => store.set(name, data),\r\n      delete: name => store.remove(name),\r\n      clear: () => store.clear(),\r\n      download: name => downloadFile(store, name),\r\n      upload: file => uploadFile(store, files, file),\r\n      fileUrl: async name => {\r\n        const file = await store.get(name.toLowerCase());\r\n        if (file) {\r\n          const blob = new Blob([file], {type: 'binary/octet-stream'});\r\n          return URL.createObjectURL(blob);\r\n        }\r\n      },\r\n    };\r\n  } catch (e) {\r\n    window.DownloadFile = () => console.error('IndexedDB is not supported');\r\n    window.DownloadSaves = () => console.error('IndexedDB is not supported');\r\n    return {\r\n      files: new Map(),\r\n      update: () => Promise.resolve(),\r\n      delete: () => Promise.resolve(),\r\n      clear: () => Promise.resolve(),\r\n      download: () => Promise.resolve(),\r\n      upload: () => Promise.resolve(),\r\n      fileUrl: () => Promise.resolve(),\r\n    };\r\n  }  \r\n}\r\n","import create_fs from './fs';\r\n\r\nconst fs = create_fs();\r\nwindow.addEventListener('message', ({data, source}) => {\r\n  if (data.method === 'transfer') {\r\n    fs.then(({files}) => {\r\n      source.postMessage({method: 'storage', files}, '*');\r\n    });\r\n  } else if (data.method === 'clear') {\r\n    fs.then(({clear}) => clear());\r\n  }\r\n});"],"sourceRoot":""}